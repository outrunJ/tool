// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package tool

func SliceIndex_TBool(v bool, s *[]bool) int {
	for ind, s1 := range *s {
		if v == s1 {
			return ind
		}
	}
	return -1
}

func SliceEach_TBool(each func(bool), s *[]bool) {
	for _, v := range *s {
		each(v)
	}
}

func SliceSliceEach_TBool(each func(*[]bool), ss *[]*[]bool) {
	for _, s := range *ss {
		each(s)
	}
}

func SliceWithout_TBool(s *[]bool, v ...bool) *[]bool {
	retS := new([]bool)
	for _, s1 := range *s {
		if SliceIndex_TBool(s1, &v) == -1 {
			*retS = append(*retS, s1)
		}
	}
	return retS
}

func SliceRepeat_TBool(v bool, n int) *[]bool {
	s := make([]bool, n)
	for i := 0; i < n; i++ {
		s[i] = v
	}
	return &s
}

func SliceIntersection_TBool(ss ...*[]bool) *[]bool {
	if len(ss) == 0 {
		return &[]bool{}
	}

	return SliceSliceReduce_TBoolRTBool(func(orin *[]bool, s *[]bool) *[]bool {
		retS := new([]bool)
		SliceEach_TBool(func(v bool) {
			if SliceIndex_TBool(v, orin) != -1 {
				*retS = append(*retS, v)
			}
		}, s)
		return retS
	}, &ss, ss[0])
}

func SliceUnion_TBool(ss ...*[]bool) *[]bool {
	retS := new([]bool)
	SliceSliceEach_TBool(func(s *[]bool) {
		SliceEach_TBool(func(v bool) {
			if SliceIndex_TBool(v, retS) == -1 {
				*retS = append(*retS, v)
			}
		}, s)
	}, &ss)
	return retS
}

func SliceIndex_TInt(v int, s *[]int) int {
	for ind, s1 := range *s {
		if v == s1 {
			return ind
		}
	}
	return -1
}

func SliceEach_TInt(each func(int), s *[]int) {
	for _, v := range *s {
		each(v)
	}
}

func SliceSliceEach_TInt(each func(*[]int), ss *[]*[]int) {
	for _, s := range *ss {
		each(s)
	}
}

func SliceWithout_TInt(s *[]int, v ...int) *[]int {
	retS := new([]int)
	for _, s1 := range *s {
		if SliceIndex_TInt(s1, &v) == -1 {
			*retS = append(*retS, s1)
		}
	}
	return retS
}

func SliceRepeat_TInt(v int, n int) *[]int {
	s := make([]int, n)
	for i := 0; i < n; i++ {
		s[i] = v
	}
	return &s
}

func SliceIntersection_TInt(ss ...*[]int) *[]int {
	if len(ss) == 0 {
		return &[]int{}
	}

	return SliceSliceReduce_TIntRTInt(func(orin *[]int, s *[]int) *[]int {
		retS := new([]int)
		SliceEach_TInt(func(v int) {
			if SliceIndex_TInt(v, orin) != -1 {
				*retS = append(*retS, v)
			}
		}, s)
		return retS
	}, &ss, ss[0])
}

func SliceUnion_TInt(ss ...*[]int) *[]int {
	retS := new([]int)
	SliceSliceEach_TInt(func(s *[]int) {
		SliceEach_TInt(func(v int) {
			if SliceIndex_TInt(v, retS) == -1 {
				*retS = append(*retS, v)
			}
		}, s)
	}, &ss)
	return retS
}

func SliceIndex_TString(v string, s *[]string) int {
	for ind, s1 := range *s {
		if v == s1 {
			return ind
		}
	}
	return -1
}

func SliceEach_TString(each func(string), s *[]string) {
	for _, v := range *s {
		each(v)
	}
}

func SliceSliceEach_TString(each func(*[]string), ss *[]*[]string) {
	for _, s := range *ss {
		each(s)
	}
}

func SliceWithout_TString(s *[]string, v ...string) *[]string {
	retS := new([]string)
	for _, s1 := range *s {
		if SliceIndex_TString(s1, &v) == -1 {
			*retS = append(*retS, s1)
		}
	}
	return retS
}

func SliceRepeat_TString(v string, n int) *[]string {
	s := make([]string, n)
	for i := 0; i < n; i++ {
		s[i] = v
	}
	return &s
}

func SliceIntersection_TString(ss ...*[]string) *[]string {
	if len(ss) == 0 {
		return &[]string{}
	}

	return SliceSliceReduce_TStringRTString(func(orin *[]string, s *[]string) *[]string {
		retS := new([]string)
		SliceEach_TString(func(v string) {
			if SliceIndex_TString(v, orin) != -1 {
				*retS = append(*retS, v)
			}
		}, s)
		return retS
	}, &ss, ss[0])
}

func SliceUnion_TString(ss ...*[]string) *[]string {
	retS := new([]string)
	SliceSliceEach_TString(func(s *[]string) {
		SliceEach_TString(func(v string) {
			if SliceIndex_TString(v, retS) == -1 {
				*retS = append(*retS, v)
			}
		}, s)
	}, &ss)
	return retS
}

func SliceIndex_TInterface(v interface{}, s *[]interface{}) int {
	for ind, s1 := range *s {
		if v == s1 {
			return ind
		}
	}
	return -1
}

func SliceEach_TInterface(each func(interface{}), s *[]interface{}) {
	for _, v := range *s {
		each(v)
	}
}

func SliceSliceEach_TInterface(each func(*[]interface{}), ss *[]*[]interface{}) {
	for _, s := range *ss {
		each(s)
	}
}

func SliceWithout_TInterface(s *[]interface{}, v ...interface{}) *[]interface{} {
	retS := new([]interface{})
	for _, s1 := range *s {
		if SliceIndex_TInterface(s1, &v) == -1 {
			*retS = append(*retS, s1)
		}
	}
	return retS
}

func SliceRepeat_TInterface(v interface{}, n int) *[]interface{} {
	s := make([]interface{}, n)
	for i := 0; i < n; i++ {
		s[i] = v
	}
	return &s
}

func SliceIntersection_TInterface(ss ...*[]interface{}) *[]interface{} {
	if len(ss) == 0 {
		return &[]interface{}{}
	}

	return SliceSliceReduce_TInterfaceRTInterface(func(orin *[]interface{}, s *[]interface{}) *[]interface{} {
		retS := new([]interface{})
		SliceEach_TInterface(func(v interface{}) {
			if SliceIndex_TInterface(v, orin) != -1 {
				*retS = append(*retS, v)
			}
		}, s)
		return retS
	}, &ss, ss[0])
}

func SliceUnion_TInterface(ss ...*[]interface{}) *[]interface{} {
	retS := new([]interface{})
	SliceSliceEach_TInterface(func(s *[]interface{}) {
		SliceEach_TInterface(func(v interface{}) {
			if SliceIndex_TInterface(v, retS) == -1 {
				*retS = append(*retS, v)
			}
		}, s)
	}, &ss)
	return retS
}
