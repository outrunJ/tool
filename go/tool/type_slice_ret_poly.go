// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package tool

func Slice2Slice_TBoolRTBool(slice *[]bool) *[]bool {
	rst := make([]bool, len(*slice))
	for i, v := range *slice {
		rst[i] = Bool2Bool(v)
	}
	return &rst
}

func SliceReduce_TBoolRTBool(reduce func(bool, bool) bool, s *[]bool, ret bool) bool {
	SliceEach_TBool(func(v bool) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TBoolRTBool(reduce func(*[]bool, *[]bool) *[]bool, ss *[]*[]bool, retS *[]bool) *[]bool {
	SliceSliceEach_TBool(func(s *[]bool) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TBoolRTBool(s *[]bool, fn func(bool) (bool, error)) (*[]bool, error) {
	var err error
	retS := make([]bool, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TBoolRTInt(slice *[]bool) *[]int {
	rst := make([]int, len(*slice))
	for i, v := range *slice {
		rst[i] = Bool2Int(v)
	}
	return &rst
}

func SliceReduce_TBoolRTInt(reduce func(int, bool) int, s *[]bool, ret int) int {
	SliceEach_TBool(func(v bool) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TBoolRTInt(reduce func(*[]int, *[]bool) *[]int, ss *[]*[]bool, retS *[]int) *[]int {
	SliceSliceEach_TBool(func(s *[]bool) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TBoolRTInt(s *[]bool, fn func(bool) (int, error)) (*[]int, error) {
	var err error
	retS := make([]int, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TBoolRTString(slice *[]bool) *[]string {
	rst := make([]string, len(*slice))
	for i, v := range *slice {
		rst[i] = Bool2String(v)
	}
	return &rst
}

func SliceReduce_TBoolRTString(reduce func(string, bool) string, s *[]bool, ret string) string {
	SliceEach_TBool(func(v bool) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TBoolRTString(reduce func(*[]string, *[]bool) *[]string, ss *[]*[]bool, retS *[]string) *[]string {
	SliceSliceEach_TBool(func(s *[]bool) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TBoolRTString(s *[]bool, fn func(bool) (string, error)) (*[]string, error) {
	var err error
	retS := make([]string, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TBoolRTInterface(slice *[]bool) *[]interface{} {
	rst := make([]interface{}, len(*slice))
	for i, v := range *slice {
		rst[i] = Bool2Interface(v)
	}
	return &rst
}

func SliceReduce_TBoolRTInterface(reduce func(interface{}, bool) interface{}, s *[]bool, ret interface{}) interface{} {
	SliceEach_TBool(func(v bool) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TBoolRTInterface(reduce func(*[]interface{}, *[]bool) *[]interface{}, ss *[]*[]bool, retS *[]interface{}) *[]interface{} {
	SliceSliceEach_TBool(func(s *[]bool) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TBoolRTInterface(s *[]bool, fn func(bool) (interface{}, error)) (*[]interface{}, error) {
	var err error
	retS := make([]interface{}, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TIntRTBool(slice *[]int) *[]bool {
	rst := make([]bool, len(*slice))
	for i, v := range *slice {
		rst[i] = Int2Bool(v)
	}
	return &rst
}

func SliceReduce_TIntRTBool(reduce func(bool, int) bool, s *[]int, ret bool) bool {
	SliceEach_TInt(func(v int) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TIntRTBool(reduce func(*[]bool, *[]int) *[]bool, ss *[]*[]int, retS *[]bool) *[]bool {
	SliceSliceEach_TInt(func(s *[]int) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TIntRTBool(s *[]int, fn func(int) (bool, error)) (*[]bool, error) {
	var err error
	retS := make([]bool, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TIntRTInt(slice *[]int) *[]int {
	rst := make([]int, len(*slice))
	for i, v := range *slice {
		rst[i] = Int2Int(v)
	}
	return &rst
}

func SliceReduce_TIntRTInt(reduce func(int, int) int, s *[]int, ret int) int {
	SliceEach_TInt(func(v int) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TIntRTInt(reduce func(*[]int, *[]int) *[]int, ss *[]*[]int, retS *[]int) *[]int {
	SliceSliceEach_TInt(func(s *[]int) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TIntRTInt(s *[]int, fn func(int) (int, error)) (*[]int, error) {
	var err error
	retS := make([]int, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TIntRTString(slice *[]int) *[]string {
	rst := make([]string, len(*slice))
	for i, v := range *slice {
		rst[i] = Int2String(v)
	}
	return &rst
}

func SliceReduce_TIntRTString(reduce func(string, int) string, s *[]int, ret string) string {
	SliceEach_TInt(func(v int) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TIntRTString(reduce func(*[]string, *[]int) *[]string, ss *[]*[]int, retS *[]string) *[]string {
	SliceSliceEach_TInt(func(s *[]int) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TIntRTString(s *[]int, fn func(int) (string, error)) (*[]string, error) {
	var err error
	retS := make([]string, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TIntRTInterface(slice *[]int) *[]interface{} {
	rst := make([]interface{}, len(*slice))
	for i, v := range *slice {
		rst[i] = Int2Interface(v)
	}
	return &rst
}

func SliceReduce_TIntRTInterface(reduce func(interface{}, int) interface{}, s *[]int, ret interface{}) interface{} {
	SliceEach_TInt(func(v int) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TIntRTInterface(reduce func(*[]interface{}, *[]int) *[]interface{}, ss *[]*[]int, retS *[]interface{}) *[]interface{} {
	SliceSliceEach_TInt(func(s *[]int) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TIntRTInterface(s *[]int, fn func(int) (interface{}, error)) (*[]interface{}, error) {
	var err error
	retS := make([]interface{}, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TStringRTBool(slice *[]string) *[]bool {
	rst := make([]bool, len(*slice))
	for i, v := range *slice {
		rst[i] = String2Bool(v)
	}
	return &rst
}

func SliceReduce_TStringRTBool(reduce func(bool, string) bool, s *[]string, ret bool) bool {
	SliceEach_TString(func(v string) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TStringRTBool(reduce func(*[]bool, *[]string) *[]bool, ss *[]*[]string, retS *[]bool) *[]bool {
	SliceSliceEach_TString(func(s *[]string) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TStringRTBool(s *[]string, fn func(string) (bool, error)) (*[]bool, error) {
	var err error
	retS := make([]bool, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TStringRTInt(slice *[]string) *[]int {
	rst := make([]int, len(*slice))
	for i, v := range *slice {
		rst[i] = String2Int(v)
	}
	return &rst
}

func SliceReduce_TStringRTInt(reduce func(int, string) int, s *[]string, ret int) int {
	SliceEach_TString(func(v string) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TStringRTInt(reduce func(*[]int, *[]string) *[]int, ss *[]*[]string, retS *[]int) *[]int {
	SliceSliceEach_TString(func(s *[]string) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TStringRTInt(s *[]string, fn func(string) (int, error)) (*[]int, error) {
	var err error
	retS := make([]int, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TStringRTString(slice *[]string) *[]string {
	rst := make([]string, len(*slice))
	for i, v := range *slice {
		rst[i] = String2String(v)
	}
	return &rst
}

func SliceReduce_TStringRTString(reduce func(string, string) string, s *[]string, ret string) string {
	SliceEach_TString(func(v string) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TStringRTString(reduce func(*[]string, *[]string) *[]string, ss *[]*[]string, retS *[]string) *[]string {
	SliceSliceEach_TString(func(s *[]string) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TStringRTString(s *[]string, fn func(string) (string, error)) (*[]string, error) {
	var err error
	retS := make([]string, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TStringRTInterface(slice *[]string) *[]interface{} {
	rst := make([]interface{}, len(*slice))
	for i, v := range *slice {
		rst[i] = String2Interface(v)
	}
	return &rst
}

func SliceReduce_TStringRTInterface(reduce func(interface{}, string) interface{}, s *[]string, ret interface{}) interface{} {
	SliceEach_TString(func(v string) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TStringRTInterface(reduce func(*[]interface{}, *[]string) *[]interface{}, ss *[]*[]string, retS *[]interface{}) *[]interface{} {
	SliceSliceEach_TString(func(s *[]string) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TStringRTInterface(s *[]string, fn func(string) (interface{}, error)) (*[]interface{}, error) {
	var err error
	retS := make([]interface{}, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TInterfaceRTBool(slice *[]interface{}) *[]bool {
	rst := make([]bool, len(*slice))
	for i, v := range *slice {
		rst[i] = Interface2Bool(v)
	}
	return &rst
}

func SliceReduce_TInterfaceRTBool(reduce func(bool, interface{}) bool, s *[]interface{}, ret bool) bool {
	SliceEach_TInterface(func(v interface{}) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TInterfaceRTBool(reduce func(*[]bool, *[]interface{}) *[]bool, ss *[]*[]interface{}, retS *[]bool) *[]bool {
	SliceSliceEach_TInterface(func(s *[]interface{}) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TInterfaceRTBool(s *[]interface{}, fn func(interface{}) (bool, error)) (*[]bool, error) {
	var err error
	retS := make([]bool, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TInterfaceRTInt(slice *[]interface{}) *[]int {
	rst := make([]int, len(*slice))
	for i, v := range *slice {
		rst[i] = Interface2Int(v)
	}
	return &rst
}

func SliceReduce_TInterfaceRTInt(reduce func(int, interface{}) int, s *[]interface{}, ret int) int {
	SliceEach_TInterface(func(v interface{}) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TInterfaceRTInt(reduce func(*[]int, *[]interface{}) *[]int, ss *[]*[]interface{}, retS *[]int) *[]int {
	SliceSliceEach_TInterface(func(s *[]interface{}) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TInterfaceRTInt(s *[]interface{}, fn func(interface{}) (int, error)) (*[]int, error) {
	var err error
	retS := make([]int, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TInterfaceRTString(slice *[]interface{}) *[]string {
	rst := make([]string, len(*slice))
	for i, v := range *slice {
		rst[i] = Interface2String(v)
	}
	return &rst
}

func SliceReduce_TInterfaceRTString(reduce func(string, interface{}) string, s *[]interface{}, ret string) string {
	SliceEach_TInterface(func(v interface{}) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TInterfaceRTString(reduce func(*[]string, *[]interface{}) *[]string, ss *[]*[]interface{}, retS *[]string) *[]string {
	SliceSliceEach_TInterface(func(s *[]interface{}) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TInterfaceRTString(s *[]interface{}, fn func(interface{}) (string, error)) (*[]string, error) {
	var err error
	retS := make([]string, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}

func Slice2Slice_TInterfaceRTInterface(slice *[]interface{}) *[]interface{} {
	rst := make([]interface{}, len(*slice))
	for i, v := range *slice {
		rst[i] = Interface2Interface(v)
	}
	return &rst
}

func SliceReduce_TInterfaceRTInterface(reduce func(interface{}, interface{}) interface{}, s *[]interface{}, ret interface{}) interface{} {
	SliceEach_TInterface(func(v interface{}) {
		ret = reduce(ret, v)
	}, s)
	return ret
}

func SliceSliceReduce_TInterfaceRTInterface(reduce func(*[]interface{}, *[]interface{}) *[]interface{}, ss *[]*[]interface{}, retS *[]interface{}) *[]interface{} {
	SliceSliceEach_TInterface(func(s *[]interface{}) {
		retS = reduce(retS, s)
	}, ss)
	return retS
}

func SliceMap_TInterfaceRTInterface(s *[]interface{}, fn func(interface{}) (interface{}, error)) (*[]interface{}, error) {
	var err error
	retS := make([]interface{}, len(*s))

	for ind, v := range *s {
		retS[ind], err = fn(v)
		if err != nil {
			return nil, err
		}
	}
	return &retS, nil
}
