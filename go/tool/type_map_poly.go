// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package tool

func MapDeleteZero_KBoolVBool(m *map[bool]bool) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KBoolVBool(m *map[bool]bool) *map[bool]bool {
	retMap := map[bool]bool{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KBoolVBool(m *map[bool]bool) *[]bool {
	keys := make([]bool, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KBoolVBool(m *map[bool]bool, keys ...bool) *[]bool {
	keysLen := len(keys)
	values := new([]bool)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KBoolVBool(maps ...*map[bool]bool) *map[bool]bool {
	retM := map[bool]bool{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KBoolVInt(m *map[bool]int) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KBoolVInt(m *map[bool]int) *map[bool]int {
	retMap := map[bool]int{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KBoolVInt(m *map[bool]int) *[]bool {
	keys := make([]bool, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KBoolVInt(m *map[bool]int, keys ...bool) *[]int {
	keysLen := len(keys)
	values := new([]int)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KBoolVInt(maps ...*map[bool]int) *map[bool]int {
	retM := map[bool]int{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KBoolVString(m *map[bool]string) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KBoolVString(m *map[bool]string) *map[bool]string {
	retMap := map[bool]string{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KBoolVString(m *map[bool]string) *[]bool {
	keys := make([]bool, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KBoolVString(m *map[bool]string, keys ...bool) *[]string {
	keysLen := len(keys)
	values := new([]string)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KBoolVString(maps ...*map[bool]string) *map[bool]string {
	retM := map[bool]string{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KBoolVInterface(m *map[bool]interface{}) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KBoolVInterface(m *map[bool]interface{}) *map[bool]interface{} {
	retMap := map[bool]interface{}{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KBoolVInterface(m *map[bool]interface{}) *[]bool {
	keys := make([]bool, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KBoolVInterface(m *map[bool]interface{}, keys ...bool) *[]interface{} {
	keysLen := len(keys)
	values := new([]interface{})

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KBoolVInterface(maps ...*map[bool]interface{}) *map[bool]interface{} {
	retM := map[bool]interface{}{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KIntVBool(m *map[int]bool) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KIntVBool(m *map[int]bool) *map[int]bool {
	retMap := map[int]bool{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KIntVBool(m *map[int]bool) *[]int {
	keys := make([]int, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KIntVBool(m *map[int]bool, keys ...int) *[]bool {
	keysLen := len(keys)
	values := new([]bool)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KIntVBool(maps ...*map[int]bool) *map[int]bool {
	retM := map[int]bool{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KIntVInt(m *map[int]int) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KIntVInt(m *map[int]int) *map[int]int {
	retMap := map[int]int{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KIntVInt(m *map[int]int) *[]int {
	keys := make([]int, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KIntVInt(m *map[int]int, keys ...int) *[]int {
	keysLen := len(keys)
	values := new([]int)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KIntVInt(maps ...*map[int]int) *map[int]int {
	retM := map[int]int{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KIntVString(m *map[int]string) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KIntVString(m *map[int]string) *map[int]string {
	retMap := map[int]string{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KIntVString(m *map[int]string) *[]int {
	keys := make([]int, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KIntVString(m *map[int]string, keys ...int) *[]string {
	keysLen := len(keys)
	values := new([]string)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KIntVString(maps ...*map[int]string) *map[int]string {
	retM := map[int]string{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KIntVInterface(m *map[int]interface{}) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KIntVInterface(m *map[int]interface{}) *map[int]interface{} {
	retMap := map[int]interface{}{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KIntVInterface(m *map[int]interface{}) *[]int {
	keys := make([]int, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KIntVInterface(m *map[int]interface{}, keys ...int) *[]interface{} {
	keysLen := len(keys)
	values := new([]interface{})

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KIntVInterface(maps ...*map[int]interface{}) *map[int]interface{} {
	retM := map[int]interface{}{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KStringVBool(m *map[string]bool) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KStringVBool(m *map[string]bool) *map[string]bool {
	retMap := map[string]bool{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KStringVBool(m *map[string]bool) *[]string {
	keys := make([]string, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KStringVBool(m *map[string]bool, keys ...string) *[]bool {
	keysLen := len(keys)
	values := new([]bool)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KStringVBool(maps ...*map[string]bool) *map[string]bool {
	retM := map[string]bool{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KStringVInt(m *map[string]int) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KStringVInt(m *map[string]int) *map[string]int {
	retMap := map[string]int{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KStringVInt(m *map[string]int) *[]string {
	keys := make([]string, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KStringVInt(m *map[string]int, keys ...string) *[]int {
	keysLen := len(keys)
	values := new([]int)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KStringVInt(maps ...*map[string]int) *map[string]int {
	retM := map[string]int{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KStringVString(m *map[string]string) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KStringVString(m *map[string]string) *map[string]string {
	retMap := map[string]string{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KStringVString(m *map[string]string) *[]string {
	keys := make([]string, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KStringVString(m *map[string]string, keys ...string) *[]string {
	keysLen := len(keys)
	values := new([]string)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KStringVString(maps ...*map[string]string) *map[string]string {
	retM := map[string]string{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KStringVInterface(m *map[string]interface{}) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KStringVInterface(m *map[string]interface{}) *map[string]interface{} {
	retMap := map[string]interface{}{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KStringVInterface(m *map[string]interface{}) *[]string {
	keys := make([]string, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KStringVInterface(m *map[string]interface{}, keys ...string) *[]interface{} {
	keysLen := len(keys)
	values := new([]interface{})

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KStringVInterface(maps ...*map[string]interface{}) *map[string]interface{} {
	retM := map[string]interface{}{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KInterfaceVBool(m *map[interface{}]bool) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KInterfaceVBool(m *map[interface{}]bool) *map[interface{}]bool {
	retMap := map[interface{}]bool{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KInterfaceVBool(m *map[interface{}]bool) *[]interface{} {
	keys := make([]interface{}, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KInterfaceVBool(m *map[interface{}]bool, keys ...interface{}) *[]bool {
	keysLen := len(keys)
	values := new([]bool)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KInterfaceVBool(maps ...*map[interface{}]bool) *map[interface{}]bool {
	retM := map[interface{}]bool{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KInterfaceVInt(m *map[interface{}]int) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KInterfaceVInt(m *map[interface{}]int) *map[interface{}]int {
	retMap := map[interface{}]int{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KInterfaceVInt(m *map[interface{}]int) *[]interface{} {
	keys := make([]interface{}, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KInterfaceVInt(m *map[interface{}]int, keys ...interface{}) *[]int {
	keysLen := len(keys)
	values := new([]int)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KInterfaceVInt(maps ...*map[interface{}]int) *map[interface{}]int {
	retM := map[interface{}]int{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KInterfaceVString(m *map[interface{}]string) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KInterfaceVString(m *map[interface{}]string) *map[interface{}]string {
	retMap := map[interface{}]string{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KInterfaceVString(m *map[interface{}]string) *[]interface{} {
	keys := make([]interface{}, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KInterfaceVString(m *map[interface{}]string, keys ...interface{}) *[]string {
	keysLen := len(keys)
	values := new([]string)

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KInterfaceVString(maps ...*map[interface{}]string) *map[interface{}]string {
	retM := map[interface{}]string{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}

func MapDeleteZero_KInterfaceVInterface(m *map[interface{}]interface{}) {
	for key, value := range *m {
		if IsZero(value) {
			delete(*m, key)
		}
	}
}

func MapCloneDeleteZero_KInterfaceVInterface(m *map[interface{}]interface{}) *map[interface{}]interface{} {
	retMap := map[interface{}]interface{}{}
	for key, value := range *m {
		if !IsZero(value) {
			retMap[key] = value
		}
	}
	return &retMap
}

func MapKeys_KInterfaceVInterface(m *map[interface{}]interface{}) *[]interface{} {
	keys := make([]interface{}, len(*m))
	ind := 0
	for key := range *m {
		keys[ind] = key
		ind++
	}
	return &keys
}

func MapValues_KInterfaceVInterface(m *map[interface{}]interface{}, keys ...interface{}) *[]interface{} {
	keysLen := len(keys)
	values := new([]interface{})

	if keysLen == 0 {
		for _, value := range *m {
			*values = append(*values, value)
		}
	} else {
		for _, key := range keys {
			*values = append(*values, (*m)[key])
		}
	}
	return values
}

func MapMerge_KInterfaceVInterface(maps ...*map[interface{}]interface{}) *map[interface{}]interface{} {
	retM := map[interface{}]interface{}{}
	for _, m := range maps {
		for key, value := range *m {
			retM[key] = value
		}
	}
	return &retM
}
